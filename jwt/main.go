/*
	Simple JSON WEB TOKEN Authentiation

How JWT works :-
Core Idea: Instead of username and password, a token is sent from client to server in each request.
1. Client Logs in with his credentials to generate a token.
2. Server Validates the credentials and generates the token using a secret key.
3. Server then sets this token in the Client's cookies.
4. Now the client needs to send this token for any secure endpoint request.

Terminologies :
1. Token :-
	A JWT token is a period seperated, self-contained string.
	A Token has 3 parts :- HEADER.PAYLOAD.SIGNATURE
	1. Header : It is a base64 encoded string containing the token type and Algorithm used for the "Signature".
	2. Payload : It is a base64 encoded JWT 'Claim' (data we want to embed in the token).
	3. Signature : It is a string generated by hashing the Header, Payload with a Secret.
		 The hashing algorithm is always mentioned in the Header. Eg: HMACSHA256(header + '.' + payload, secret)
	Example token : eyJhbGciOiJIUzI1NiIsIn.eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjox.306YAZpTvsXcHGu0OPXdojOPi0EJm

2. Claims :-
	Claims are statements about an entity (typically, the user) and additional data.
	The JWT claims are included in the payload and they determine which information the JWT communicates, such as:
	User identity, Permissions, Expiration of JWT, etc.
	Inshort, Claims represent information exchanged between two parties.

------

A basic JWT Auth flow :-

Assuming that the users have signed up with their credentials and their credentials (username and password) are stored in DB.
They are now redirected to sign-in page. Inorder to sign-in, they enter their credentials and hit the sign-in button.

1. Server first validates the received credentials with existing users.
2. For a valid user, after validating the credentials, the token generation takes places as follows :
	-> Claim creation :
			Server creates Claim which contains the username and standard claims (including expiry time).
		  This claims acts as a container for information that will be embedded within the token.
	-> JWT Token Creation :
			The server creates a new JWT token object with a new Claim.
			This includes specifing the Signing method (HS256 here) and the newly created Claim.
	-> Token Signing :
			The server uses the secret key stored in the server to sign the newly created JWT token object.
			Anyone with the secret key can verify the signature and confirm that the token hasn't been tampered.
	-> Token String Generation :
			Finally, the server generates the "token string" (a string representation of the signed JWT token) from the JWT token object.
	-> Cookie Setting :
			This string will be sent back to the client as a cookie or included in the response body.
3. Working with secure routes :- We can now use this jwt-token to secure our other routes from unauthorised users.
	-> Retrieving the JWT Cookie :
			The cookie can extracted from the incoming request. If the cookie is not found, set the Response Headers with appropriate errors.
	-> Extracting Token String :
			If the cookie is found successfully, we extract its value as a JWT token string.
	-> Parsing the JWT Token :
			Parse the token string using the Claim.
	-> Checking Token Validity :
			If parsing is successful, the check if the parsed token is valid.
			If the token is invalid (e.g., expired), responds with a "401 Unauthorized" error message.
*/

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/golang-jwt/jwt"
)

var jwtKey = []byte("secret-token") // [1]

var Users = map[string]string{ // [2]
	"amit":  "juicewrld999",
	"user2": "password",
	"user3": "qwerty",
	"user4": "123456",
}

type Credentials struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type Claims struct { // [3]
	Username string `json:"username"`
	jwt.StandardClaims
}

func Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var credentials Credentials
	err := json.NewDecoder(r.Body).Decode(&credentials) // [4]
	if err != nil {
		http.Error(w, "Error decoding response body", http.StatusBadRequest)
		return
	}

	expectedPassword, ok := Users[credentials.Username]
	if !ok || credentials.Password != expectedPassword {
		http.Error(w, "UnAuthorised User", http.StatusUnauthorized)
		return
	}

	expirationTime := time.Now().Add(time.Minute * 5) // [5]

	claims := &Claims{ // [6]
		Username: credentials.Username,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) // [7]

	tokenString, err := token.SignedString(jwtKey) // [8]
	if err != nil {
		http.Error(w, "Error with jwt token", http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{ // [9]
		Name:     "jwt-token",
		Value:    tokenString,
		Expires:  expirationTime,
		HttpOnly: true,
		// Secure:   true, // This Secure flag is designed to "only" transmit the cookie over "HTTPS" connections for enhanced security.
	})
}

func Home(w http.ResponseWriter, r *http.Request) {
	cookie, err := r.Cookie("jwt-token")
	if err != nil {
		if err == http.ErrNoCookie {
			http.Error(w, "Access token missing", http.StatusUnauthorized)
			return
		}
		http.Error(w, "Bad Request", http.StatusBadRequest)
		return
	}

	tokenStr := cookie.Value

	claims := &Claims{}

	tkn, err := jwt.ParseWithClaims(tokenStr, claims, func(t *jwt.Token) (interface{}, error) { return jwtKey, nil }) // [10]

	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			http.Error(w, "UnAuthorised User", http.StatusUnauthorized)
			return
		}
		http.Error(w, "Bad Request", http.StatusBadRequest)
		return
	}

	if !tkn.Valid {
		http.Error(w, "UnAuthorised User", http.StatusUnauthorized)
		return
	}

	w.Write([]byte(fmt.Sprintf("Hello, %s", claims.Username)))
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", Login)
	mux.HandleFunc("/home", Home)

	server := http.Server{
		Addr:    ":3000",
		Handler: mux,
	}
	log.Print("server listening on port :3000")
	log.Fatal(server.ListenAndServe())
}

/*
[1] : A secret which will help in creating JWT Token.
[2] : Mimicing Users from a NoSQL DB.
[3] : Creating a Claim which includes username and other standard claims.
[4] : Decoding the username and password received in the request body into the credentials struct.
[5] : Deciding an expiration time for the JWT token.
[6] : Constructing a new Claim for the current instance of a logged in user.
[7] : Creating a token for the user using a hashing algorithm & the newly constructed claim.
[8] : Generating a string representation of the token by signing it with the Secret key.
[9] : Senidng back the token to the client as a cookie named "jwt-token".
[10] : jwt.ParseWithClaims is used to parse a JWT token string and extract the embedded claims.
			 Arguments:
			 tokenStr: This is the string representation of the JWT token obtained from the cookie.
			 claims: This is a pointer to an empty Claims struct. Remember, &Claims{} creates a new instance and assigns its address to the claims variable.
			 keyFunc: This is a function that provides the key used to verify the token's signature.
			 					The keyFunc is a lambda function defined inline. It takes a single argument, t *jwt.Token.
				        It simply returns the secret key stored in the jwtKey variable to the ParseWithClaims function.
				        The jwt.ParseWithClaims function uses this key to verify the token's signature and ensure its authenticity.
*/
